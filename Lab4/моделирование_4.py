# -*- coding: utf-8 -*-
"""Моделирование 4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16Jqh1LGqhXj7YhPcJyKKSb5Bb-8DG8wd
"""

import random
from matplotlib import patches
import numpy as np
import matplotlib.pyplot as plt

"""## **Задание 1**"""

P_A = 0.8
P_B = 0.7
P_C = 0.95
P_D = 0.85
P_E = 0.9
P_F = 0.7
N = 100
count = 0

def check(p):
  return random.random() < p

for _ in range(N):
  if (check(P_A) or check(P_B)) and check(P_C) and (check(P_D) or check(P_E) or check(P_F)):
    count += 1

analitic = (1 - (1 - P_A) * (1 - P_B)) * P_C * (1 - (1 - P_D) * (1 - P_E) * (1 - P_F))
print("Аналитическая вероятность, что все будт безотказно = ", analitic)
print("Вероятность безотказных испытаний", count / N)

"""## **Задание 2**"""

def with_probability(p):
    return random.random() <= p

n = 100
count = 0
error = 0

n1, n2, n3 = 0.2, 0.3, 0.5
p1, p2, p3 = 0.8, 0.9, 0.95

for i in range(n):
    if with_probability(1 - n1) and with_probability(1 - n2) and with_probability(1 - n3):
        continue
    o = random.random()
    error += 1
    if o < n1:
        if with_probability(p1):
            count += 1
    elif n1 <= o < n1 + n2:
        if with_probability(p2):
            count += 1
    elif n1 + n2 <= o <= n1 + n2 + n3:
        if with_probability(p3):
            count += 1

print(f'Обноружено {count} ошибок из {error}')
print(f'Вероятность, что ошибка обнаружена: {count / error}')
print(f'Вероятность безотказной работы: {(n - error) / n}')

"""# **Задание 3**"""

def func(i):
  if -1 + i ** 2 < 0:
    return - pow(abs(-1 + i ** 2), 1/3)
  else:
    return pow(abs(-1 + i ** 2), 1/3)

x = np.linspace(-2, 1, 60)
y = [func(i) for i in x ]
x_2 = np.linspace(1, 2, 20)
y_2 = [(1-i) for i in x_2 ]

n = [10, 100, 1000, 10000, 100000]
for num, i in enumerate(n):
    _, ax = plt.subplots()
    lst_x, lst_y = [], []
    right = []
    for _ in range(i):
        lst_x.append(random.uniform(-2, 2))
        lst_y.append(random.uniform(-2, 2))
        if (-(lst_x[-1] ** 2) + lst_y[-1] ** 3 < -1) and (lst_x[-1] + lst_y[-1] < 1) and (-2 < lst_x[-1] < 2) and (-2 < lst_y[-1] < 2):
            right.append((lst_x.pop(), lst_y.pop()))
    
    ax.scatter(lst_x, lst_y, s=0.1)
    ax.plot(x, y, 'r', x_2, y_2,'r')
    ax.scatter(np.array(right)[:, 0], np.array(right)[:, 1], c="g", s=0.1)
    ax.add_patch(patches.Rectangle((-2, -2),
                4,
                4,
                edgecolor = 'yellow',
                facecolor='none'))
    
    result = 16 * len(right) / i 
    print(f'--- {i} ---')
    print(f'{result} < 6,84359') if result < 6.84359 else print(f'{result} > 6,84359')
plt.show()

"""# **Задание 4**"""

n = 100000
detail_cost = 35
material_cost = 20 # Цена материала
expenditure_cnc = 5 # Цена первого станка
expenditure_polish = 4 # Цена второго станка
expenditure_gt_thick = 3 # Исправление детали после первого станка
expenditure_polish_correction = 2 # Исправление детали на втором станке
cnc_less = 0.08
cnc_gt = 0.12
polish_up_proc = 0.03 # Верхняя поверхность
polish_dn_proc = 0.06 # Нижняя поверхность
cost = 0
detail_count = 0
profit = 0
for _ in range(n):
    cost += material_cost + expenditure_cnc
    r = random.uniform(0, 1)
    if r < cnc_less: continue
    if r > cnc_less and r < cnc_gt + cnc_less: cost += expenditure_gt_thick
    cost += expenditure_polish
    r1, r2 = random.uniform(0, 1), random.uniform(0, 1)
    if r1 < polish_up_proc and r2 < polish_dn_proc: continue
    if (r1 < polish_up_proc) ^ (r2 < polish_dn_proc):
        cost += expenditure_polish_correction
    profit += detail_cost
    detail_count += 1
print(f"Вероятность выпуска годной детали: {detail_count / n}")
print(f"Средняя прибыль предприятия: {(profit - cost) / n}")